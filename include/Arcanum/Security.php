<?php
/**
 * "Security" methods for storing passwords, cookies, auth information
 *
 * @package arcanum
 * @version $Id: Security.php 5809 2012-09-20 09:06:12Z avel $
 */

/**
 * "Security" methods for storing passwords, cookies, auth information
 */
class Arcanum_Security {
    /**
     * Saves or updates user password information
     *
     * This function is used to update password information that this app
     * stores during existing web session.
     *
     * Function must be called before any html output started.
     *
     * @param string $pass password
     * @return string password encrypted with OTP.
     * @author Squirrelmail Project Team
     * @copyright Squirrelmail Project Team
     */
    public static function savePassword($pass) {
        global $baseuri;

        $onetimepad = self::oneTimePadCreate(strlen($pass));
        $_SESSION['onetimepad'] = $onetimepad;
        $authKey = self::oneTimePadEncrypt($pass, $onetimepad);
        self::setCookie('key', $authKey, false, $baseuri, '', false, true);
        return $authKey;
    }

    /**
     * Reads and decodes stored user password information
     *
     * @return string password in plain text
     */
    public static function readPassword() {
        global $cpAuthKey;  // should have been set in init.php
        if( ($authKey = self::getAuthKey() ) === false) {
            return false;
        }
        if(!isset($_SESSION['onetimepad'])) {
            // old password is not available!
            return false;
        }
        $onetimepad = $_SESSION['onetimepad'];
        return self::oneTimePadDecrypt($authKey, $onetimepad);
    }

    public static function getAuthKey() {
        if(isset($_COOKIE['key'])) {
            return $_COOKIE['key'];
        }
        return false;
    }

    /**
     * Encrypts password
     *
     * These functions are used to encrypt the password before it is
     * stored in a cookie. The encryption key is generated by
     * OneTimePadCreate();
     *
     * @param string $string the (password)string to encrypt
     * @param string $epad the encryption key
     * @return string the base64-encoded encrypted password
     * @author Squirrelmail Project Team
     * @copyright Squirrelmail Project Team
     */
    public static function oneTimePadEncrypt ($string, $epad) {
        $pad = base64_decode($epad);

        if (strlen($pad)>0) {
            // make sure that pad is longer than string
            while (strlen($string)>strlen($pad)) {
                $pad.=$pad;
            }
        } else {
            // FIXME: what should we do when $epad is not base64 encoded or empty.
        }

        $encrypted = '';
        for ($i = 0; $i < strlen ($string); $i++) {
            $encrypted .= chr (ord($string[$i]) ^ ord($pad[$i]));
        }

        return base64_encode($encrypted);
    }

    /**
     * Creates encryption key
     *
     * Creates an encryption key for encrypting the password stored in the cookie.
     * The encryption key itself is stored in the session.
     *
     * Pad must be longer or equal to encoded string length.
     *
     * @param int $length optional, length of the string to generate
     * @return string the encryption key
     * @author Squirrelmail Project Team
     * @copyright Squirrelmail Project Team
     */
    public static function oneTimePadCreate ($length=100) {
        self::mt_randomize();

        $pad = '';
        for ($i = 0; $i < $length; $i++) {
            $pad .= chr(mt_rand(0,255));
        }

        return base64_encode($pad);
    }

    /**
     * Decrypts a password from the cookie
     *
     * Decrypts a password from the cookie, encrypted by OneTimePadEncrypt.
     * This uses the encryption key that is stored in the session.
     *
     * @param string $string the string to decrypt
     * @param string $epad the encryption key from the session
     * @return string the decrypted password
     * @author Squirrelmail Project Team
     * @copyright Squirrelmail Project Team
     */
    public static function oneTimePadDecrypt ($string, $epad) {
        $pad = base64_decode($epad);

        if (strlen($pad)>0) {
            // make sure that pad is longer than string
            while (strlen($string)>strlen($pad)) {
                $pad.=$pad;
            }
        } else {
            // FIXME: what should we do when $epad is not base64 encoded or empty.
        }

        $encrypted = base64_decode ($string);
        $decrypted = '';
        for ($i = 0; $i < strlen ($encrypted); $i++) {
            $decrypted .= chr (ord($encrypted[$i]) ^ ord($pad[$i]));
        }

        return $decrypted;
    }

    /**
     * Init random number generator
     *
     * This function initializes the random number generator fairly well.
     * It also only initializes it once, so you don't accidentally get
     * the same 'random' numbers twice in one session.
     *
     * @return void
     * @author Squirrelmail Project Team
     * @copyright Squirrelmail Project Team
     */
    public static function mt_randomize() {
        static $randomized;

        if ($randomized) {
            return;
        }

        /* Global. */
        $remote_port = $_SERVER['REMOTE_PORT'];
        $remote_addr = $_SERVER['REMOTE_ADDR'];
        self::mt_seed((int)((double) microtime() * 1000000));
        self::mt_seed(md5($remote_port . $remote_addr . getmypid()));

        /* getrusage */
        if (function_exists('getrusage')) {
            /* Avoid warnings with Win32 */
            $dat = @getrusage();
            if (isset($dat) && is_array($dat)) {
                $Str = '';
                foreach ($dat as $k => $v)
                    {
                        $Str .= $k . $v;
                    }
                self::mt_seed(md5($Str));
            }
        }

        if(!empty($_SERVER['UNIQUE_ID'])) {
            self::mt_seed(md5($_SERVER['UNIQUE_ID']));
        }

        $randomized = 1;
    }

    /**
     * Randomizes the mt_rand() function.
     *
     * Toss this in strings or integers and it will seed the generator
     * appropriately. With strings, it is better to get them long.
     * Use md5() to lengthen smaller strings.
     *
     * @param mixed $val a value to seed the random number generator. mixed = integer or string.
     * @return void
     * @author Squirrelmail Project Team
     * @copyright Squirrelmail Project Team
     */
    public static function mt_seed($Val) {
        /* if mt_getrandmax() does not return a 2^n - 1 number,
           this might not work well.  This uses $Max as a bitmask. */
        $Max = mt_getrandmax();

        if (! is_int($Val)) {
                $Val = crc32($Val);
        }

        if ($Val < 0) {
            $Val *= -1;
        }

        if ($Val == 0) {
            return;
        }

        mt_srand(($Val ^ mt_rand(0, $Max)) & $Max);
    }

    /**
     * Set a cookie
     * @param string  $sName     The name of the cookie.
     * @param string  $sValue    The value of the cookie.
     * @param int     $iExpire   The time the cookie expires. This is a Unix timestamp so is in number of seconds since the epoch.
     * @param string  $sPath     The path on the server in which the cookie will be available on.
     * @param string  $sDomain   The domain that the cookie is available.
     * @param boolean $bSecure   Indicates that the cookie should only be transmitted over a secure HTTPS connection.
     * @param boolean $bHttpOnly Disallow JS to access the cookie (IE6 only)
     * @return void
     * @author Squirrelmail Project Team
     * @copyright Squirrelmail Project Team
     */
    public static function setCookie($sName,$sValue='deleted',$iExpire=0,$sPath="",$sDomain="",$bSecure=false,$bHttpOnly=false) {
        // if we have a secure connection then limit the cookies to https only.
        if ($sName && isset($_SERVER['HTTPS']) && $_SERVER['HTTPS']) {
            $bSecure = true;
        }

        // admin config can override the restriction of secure-only cookies
        global $only_secure_cookies;
        if (!$only_secure_cookies)
            $bSecure = false;

        if (false) { // check_php_version(5,2)) {
           // php 5 supports the httponly attribute in setcookie, but because setcookie seems a bit
           // broken we use the header function for php 5.2 as well. We might change that later.
           //setcookie($sName,$sValue,(int) $iExpire,$sPath,$sDomain,$bSecure,$bHttpOnly);
        } else {
            if (!empty($Domain)) {
                // Fix the domain to accept domains with and without 'www.'.
                if (strtolower(substr($Domain, 0, 4)) == 'www.')  $Domain = substr($Domain, 4);
                $Domain = '.' . $Domain;

                // Remove port information.
                $Port = strpos($Domain, ':');
                if ($Port !== false)  $Domain = substr($Domain, 0, $Port);
            }
            if (!$sValue) $sValue = 'deleted';
            header('Set-Cookie: ' . rawurlencode($sName) . '=' . rawurlencode($sValue)
                                . (empty($iExpires) ? '' : '; expires=' . gmdate('D, d-M-Y H:i:s', $iExpires) . ' GMT')
                                . (empty($sPath) ? '' : '; path=' . $sPath)
                                . (empty($sDomain) ? '' : '; domain=' . $sDomain)
                                . (!$bSecure ? '' : '; secure')
                                . (!$bHttpOnly ? '' : '; HttpOnly'), false);
        }
    }
}

